; Шаг | Стек после инструкции | Инструкция
; 1. [0r]                 ; push hello_str
; 2. [0r, 13]             ; load
; 3. [0r, 13]             ; 13 != 0 - продолжаем   << cycle
; 4. [13, 0r]             ; swap
; 5. [13, 1r]             ; inc
; 6. [13, 1r, 72('H')]    ; load
; 7. [13, 1r, 72('H')]    ; output 1 -- вывели 'H'
; 8. [13, 1r]             ; pop
; 9. [1r, 13]             ; swap
; 10.[1r, 12]             ; dec
; 11.[1r, 12]             ; jmp cycle              >> cycle
; 3. [1r, 12]             ; 12 != 0 - продолжаем   << cycle
; 4. [12, 1r]             ; swap
; 5. [12, 2r]             ; inc
; 6. [12, 2r, 101('e')]   ; load
; 7. [12, 2r, 101('e')]   ; output 1 -- вывели 'e'
; 8. [12, 2r]             ; pop
; 9. [2r, 12]             ; swap
; 10.[2r, 12]             ; dec
; 11.[2r, 11]             ; jmp cycle
; ...
; 3. [13r, 0]             ; 0 == 0 - выходим      >> exit
; 12.[13r]                ; pop
; 13.[]                   ; pop
; 14.[]                   ; halt
; EXIT 0

.data
hello_str: "Hello, world!"

.text
_start:
        push hello_str ; 1. помещаем адрес переменной hello_str (адрес начала строки) в стек
        load           ; 2. загружаю на вершину стэка значение по адресу вершины стэка - длину Pascal-строки
cycle:
        jz ext         ; 3. если длина 0, то выходим
        swap           ; 4. теперь на верхушке адрес
        inc            ; 5. увеличиваем на 1, получаем адрес следующего символа
        load           ; 6. загружаем символ из памяти по адресу
        output 1       ; 7. вывод по порту для вывода
        pop            ; 8. удаляем символ, теперь на вершине опять адрес символа
        swap           ; 9. теперь на верхушке длина строки
        dec            ; 10. уменьшаем на 1
        jmp cycle      ; 11. безусловный переход
ext:
        pop            ; 12. очищаем стек
        pop            ; 13. очищаем стек
        halt           ; 14. завершение работы
